<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Arena — Salas Infinitas, Inimigos Acumulativos, Mutações/Upgrades</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:Verdana,Arial,Helvetica,sans-serif}
  #wrap{height:100%;display:flex;align-items:center;justify-content:center;position:relative}
  canvas{border:0.5rem outset pink;background:#222;display:block}
  #hud{position:absolute;left:12px;top:12px;color:#fff;font-size:13px;line-height:1.4}
  #menu,#gameover{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background:rgba(0,0,0,0.6)}
  button{padding:8px 12px;margin:6px;font-size:14px;cursor:pointer}
  .small{font-size:12px;color:#bbb}
  #detailPanel{position:absolute;right:12px;top:12px;background:rgba(0,0,0,0.4);padding:8px;border-radius:6px;max-width:320px}
  .mut-list{max-height:220px;overflow:auto}
  .special-bar { width:180px; height:12px; background:rgba(255,255,255,0.08); border-radius:6px; overflow:hidden; display:inline-block; vertical-align:middle; margin-left:8px; }
  .special-fill { height:100%; background:linear-gradient(90deg,#ffb347,#ffcc33); }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="ctx" width="900" height="800"></canvas>

  <div id="hud"></div>

  <div id="detailPanel" style="display:none">
    <div style="font-weight:bold">Detalhes (TAB para fechar)</div>
    <div id="detailUpgrades" class="small"></div>
    <div id="detailMutations" class="small mut-list" style="margin-top:6px"></div>
  </div>

  <div id="menu">
    <h2>Arena — Salas Infinitas</h2>
    <div class="small">WASD mover • Clique atira • Botão direito special • TAB mostra detalhes</div>
    <button id="btnStart">Iniciar Run</button>
    <div class="small">Inimigos acumulam por sala. A cada 4 salas aparece um boss.</div>
  </div>

  <div id="gameover" style="display:none">
    <h2>GAME OVER</h2>
    <div id="goStats" class="small" style="margin-bottom:8px"></div>
    <button id="btnRestart">Recomeçar</button>
  </div>
</div>

<!-- Audio files (optional, keep paths) -->
<audio id="shoot" src="./sounds/shoot.wav"></audio>
<audio id="bigshoot" src="./sounds/bigshoot.wav"></audio>
<audio id="supershoot" src="./sounds/supershoot.wav"></audio>
<audio id="powerup" src="./sounds/powerup.wav"></audio>
<audio id="coin" src="./sounds/coin.wav"></audio>
<audio id="hit" src="./sounds/hit.wav"></audio>

<script>
/* ===========================================================
   Atualizado: Salas infinitas + contato dano + obstáculos + boss cada 4 salas
   Mantive e expandi sua base. Objetivos:
   - Salas geradas infinitamente
   - A cada 4 salas: boss forte
   - Inimigos causam dano ao tocar o player (com cooldown)
   - 0-4 obstáculos por sala
   - Pickups "score" e "recharge" spawn por sala com 4-6% de chance (muito raro)
   - Barra de special no HUD
   ===========================================================*/

/* ------------------ Config / Globals ------------------ */
const canvas = document.getElementById('ctx');
const ctx = canvas.getContext('2d');
const HUD = document.getElementById('hud');
const menu = document.getElementById('menu');
const gameover = document.getElementById('gameover');
const goStats = document.getElementById('goStats');
const detailPanel = document.getElementById('detailPanel');
const detailUpgrades = document.getElementById('detailUpgrades');
const detailMutations = document.getElementById('detailMutations');
const btnStart = document.getElementById('btnStart');
const btnRestart = document.getElementById('btnRestart');

const WIDTH = canvas.width, HEIGHT = canvas.height;

/* audio helpers */
const S = {
  shoot: document.getElementById('shoot'),
  bigshoot: document.getElementById('bigshoot'),
  supershoot: document.getElementById('supershoot'),
  powerup: document.getElementById('powerup'),
  coin: document.getElementById('coin'),
  hit: document.getElementById('hit')
};
function safePlay(a){ try{ a.currentTime=0; a.play(); } catch(e){} }

/* game state */
let state = 'menu'; // menu | running | gameover
let player, enemies, bullets, pickups, floatingText, obstacles;
let lastTs = 0;
let score = 0;
let level = 1; // visual power / difficulty indicator (increases por sala)
let roomIndex = 1; // sala atual (começa em 1)
let roomsSinceBoss = 0; // contador para boss (boss a cada 4 salas)

/* progression values */
let enemyPool = ['basic']; // accumulative types
let enemiesToKillThisRoom = 6; // kills needed to clear room (escala por room)
let killsThisRoom = 0;

/* upgrades (numeric, no clutter) */
const Upgrades = {
  moveSpeed: 0,
  fireRate: 0,
  damage: 0,
  bulletSpeed: 0,
  maxHP: 0,
  specialCharge: 0
};

/* mutations (objects with level, apply flags) */
let Mutations = {}; // key -> { level, id, name, desc }

/* mutation & upgrade pools (extendable) */
const MUTATION_POOL = [
  {id:'double_shot', name:'Double Shot', desc:'Dispara 2 projéteis.'},
  {id:'triple_shot', name:'Triple Shot', desc:'Dispara 3 projéteis.'},
  {id:'bounce', name:'Bounce', desc:'Projéteis ricocheteiam 1 vez.'},
  {id:'pierce', name:'Pierce', desc:'Projéteis atravessam 1 inimigo.'},
  {id:'burst_on_hit', name:'Burst On Hit', desc:'Ao atingir, projétil gera mini-tiros.'},
  {id:'trail', name:'Burn Trail', desc:'Projéteis deixam trilha danosa.'},
  {id:'explode_on_death', name:'Explode', desc:'Inimigo explode ao morrer.'},
  {id:'lowhp_speed', name:'LowHP Speed', desc:'Fica mais rápido com pouca vida.'},
  {id:'vampiric', name:'Vampiric', desc:'Ganha vida ao matar.'},
  {id:'charge_shot', name:'Charge Shot', desc:'Acumula para tiro mais forte.'}
];

const UPGRADE_POOL = [
  {key:'moveSpeed', name:'Move Speed'},
  {key:'fireRate', name:'Fire Rate'},
  {key:'damage', name:'Damage'},
  {key:'bulletSpeed', name:'Bullet Speed'},
  {key:'maxHP', name:'Max HP'},
  {key:'specialCharge', name:'Special Charge'}
];

/* enemy type definitions (adicionadas propriedades de contato) */
const ENEMY_TYPES = {
  basic: { color:'maroon', baseLife:1, baseSpeed:40, contactDamage:1 },
  fast:  { color:'orangered', baseLife:1, baseSpeed:120, contactDamage:1 },
  tank:  { color:'darkred', baseLife:4, baseSpeed:28, contactDamage:2 },
  ranged:{ color:'purple', baseLife:2, baseSpeed:30, ranged:true, contactDamage:1 },
  splitter:{ color:'sienna', baseLife:2, baseSpeed:50, split:true, contactDamage:1 },
  elite:{ color:'goldenrod', baseLife:3, baseSpeed:60, contactDamage:2 },
  charger:{ color:'crimson', baseLife:4, baseSpeed:90, charge:true, contactDamage:2 },
  sniper:{ color:'navy', baseLife:2, baseSpeed:20, sniper:true, contactDamage:1 },
  bossMinion:{ color:'black', baseLife:2, baseSpeed:40, contactDamage:1 }
};

/* visual / effects */
floatingText = [];
function addFloating(x,y,txt,color='white',ttl=900){ floatingText.push({x,y,txt,color,created:performance.now(),ttl}); }

/* obstacles array */
obstacles = []; // cada obstáculo: {x,y,w,h}

/* stats */
let stats = { shots:0, hits:0, kills:0, damageTaken:0, timeSurvived:0 };

/* screen effects */
let shake = 0;
let slowTimer = 0;
let killStreak = 0;

/* spawn control */
let spawnAccumulator = 0;

/* ------------------ Utilities ------------------ */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function now(){ return performance.now(); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function rectCol(a,b){
  return a.x - a.width/2 < b.x + b.width/2 &&
         a.x + a.width/2 > b.x - b.width/2 &&
         a.y - a.height/2 < b.y + b.height/2 &&
         a.y + a.height/2 > b.y - b.height/2;
}
/* rect vs rect generic */
function rectColRaw(ax,ay,aw,ah,bx,by,bw,bh){
  return ax - aw/2 < bx + bw/2 &&
         ax + aw/2 > bx - bw/2 &&
         ay - ah/2 < by + bh/2 &&
         ay + ah/2 > by - bh/2;
}

/* ------------------ Entities ------------------ */
function createPlayer(){
  player = {
    x: WIDTH/2, y: HEIGHT/2, width:22, height:22,
    hp: 10 + Upgrades.maxHP*2, color:'lightgreen',
    AimAngle:0, atkCounter:0, atkSpeed:1 + Upgrades.fireRate*0.15,
    pressing:{up:false,down:false,left:false,right:false},
    abilities:[], // names from mutations applied
    doubleShoot:false, tripleShot:false, wideSpread:false,
    doubleDamage:false, burstOnHit:false, specialMod:1,
    hitCooldown:0 // tempo em ms para perder dano por toque continuo
  };
}

/* spawn enemy factory */
function spawnEnemyOfType(type){
  const spec = ENEMY_TYPES[type] || ENEMY_TYPES.basic;
  const id = Math.random().toString(36).slice(2);
  const spawnEdge = Math.random();
  let x,y;
  if (spawnEdge < 0.25){ x=rand(40, WIDTH-40); y=-40; }
  else if (spawnEdge < 0.5){ x=rand(40, WIDTH-40); y=HEIGHT+40; }
  else if (spawnEdge < 0.75){ x=-40; y=rand(40, HEIGHT-40); }
  else { x=WIDTH+40; y=rand(40, HEIGHT-40); }
  enemies[id] = {
    id, typeName:type, x,y, width: rand(12,28) * (type==='tank'?1.6:1), height: rand(12,28)*(type==='tank'?1.6:1),
    vx:0, vy:0, life: Math.max(1, spec.baseLife + Math.floor(level/2)), color: spec.color, spec,
    _hitTimer:0 // cooldown para dano por contato
  };
}

/* bullets & pickups */
function spawnBullet(sourceAngle, origin, opts = {}) {
  const id = Math.random().toString(36).slice(2);
  const speedBase = 650 + Upgrades.bulletSpeed*80;
  const speed = (opts.speed || speedBase);
  const damageBase = 4 + Upgrades.damage*2;
  const damage = opts.damage || damageBase;
  bullets[id] = {
    id, x: origin.x, y: origin.y, width:6, height:6,
    xs: Math.cos(sourceAngle*Math.PI/180)*speed, ys: Math.sin(sourceAngle*Math.PI/180)*speed,
    timer:0, damage, owner:'player', bounces: (Mutations['bounce']?Mutations['bounce'].level:0), pierced:0
  };
}

function spawnPickup(type, x,y){
  const id = Math.random().toString(36).slice(2);
  pickups[id] = { id, type, x:x||rand(40,WIDTH-40), y:y||rand(40,HEIGHT-40), width:14, height:14 };
}

/* ------------------ Room / Progression ------------------ */
function initRoomSystem(){
  level = 1;
  roomIndex = 1;
  roomsSinceBoss = 0;
  enemyPool = ['basic'];
  enemiesToKillThisRoom = 6;
  killsThisRoom = 0;
  spawnRoomStart(); // cria a primeira sala
}

function advanceRoom(){
  roomIndex++;
  level = 1 + Math.floor(roomIndex/1); // level escala com sala
  roomsSinceBoss++;
  // unlock enemy types in sequence (accumulative)
  const unlocks = {
    2: 'fast',
    4: 'tank',
    6: 'ranged',
    8: 'splitter',
    10: 'elite',
    12: 'charger',
    14: 'sniper',
    16: 'bossMinion'
  };
  const t = unlocks[roomIndex];
  if (t && !enemyPool.includes(t)) enemyPool.push(t);

  // scale kills needed for next room
  enemiesToKillThisRoom = Math.round(6 + roomIndex * 1.5);

  // give guaranteed level-up reward (small chance to prefer upgrade)
  giveRoomReward();

  // spawn new room layout
  spawnRoomStart();

  // if it's time for a boss (a cada 4 salas): spawn boss room
  if (roomsSinceBoss >= 4){
    roomsSinceBoss = 0;
    spawnBossForRoom(roomIndex);
  }

  addFloating(WIDTH/2, HEIGHT/2 - 30, 'PRÓXIMA SALA → ' + roomIndex, 'yellow', 1400);
}

/* reward when clearing a room (grant mutation/upgrade) */
function giveRoomReward(){
  if (Math.random() < 0.7) grantRandomMutation(); else grantRandomUpgrade();
}

/* ------------------ Mutations & Upgrades logic ------------------ */
function grantRandomMutation(){
  const notHave = MUTATION_POOL.filter(m => !Mutations[m.id]);
  const pick = (notHave.length ? notHave[Math.floor(Math.random()*notHave.length)] : MUTATION_POOL[Math.floor(Math.random()*MUTATION_POOL.length)]);
  applyMutation(pick);
}

function applyMutation(m){
  if (!Mutations[m.id]){
    Mutations[m.id] = { level:1, id:m.id, name:m.name, desc:m.desc };
    addFloating(player.x, player.y - 24, 'MUTATION: ' + m.name, 'cyan', 1200);
  } else {
    Mutations[m.id].level++;
    addFloating(player.x, player.y - 24, 'MUTATION UP: ' + m.name + ' +' + (Mutations[m.id].level-1), 'lightgreen', 1000);
  }
  applyMutationEffects();
}

function applyMutationEffects(){
  // clear flags
  player.doubleShoot = false; player.tripleShot = false; player.burstOnHit = false; player.specialMod = 1;
  if (Mutations['double_shot']) player.doubleShoot = true;
  if (Mutations['triple_shot']) player.tripleShot = true;
  if (Mutations['burst_on_hit']) player.burstOnHit = true;
  if (Mutations['charge_shot']) player.chargeShot = true;
  if (Mutations['double_shot'] && Mutations['triple_shot']) player.doubleShoot = true;
  if (Mutations['pierce']) player.pierce = true;
  if (Mutations['double_shot'] && Mutations['double_shot'].level>1) player.doubleDamage = true;
  if (Mutations['charge_shot']) { player.specialMod = Math.max(0.4, 1 - 0.08*(Mutations['charge_shot'].level-1)); }
}

/* upgrades */
function grantRandomUpgrade(){
  const pick = UPGRADE_POOL[Math.floor(Math.random()*UPGRADE_POOL.length)];
  Upgrades[pick.key] = (Upgrades[pick.key]||0) + 1;
  addFloating(player.x, player.y - 24, 'UPGRADE: ' + pick.name + ' Lvl ' + Upgrades[pick.key], 'aqua', 1000);
  applyUpgradeEffects();
}

function applyUpgradeEffects(){
  if (player){
    player.atkSpeed = 1 + (Upgrades.fireRate * 0.18);
    player.maxHP = 10 + (Upgrades.maxHP * 2);
    player.hp = Math.min(player.hp, player.maxHP);
  }
}

/* ------------------ Boss logic (muito mais HP) ------------------ */
function spawnBossForRoom(rIndex){
  // cria boss que ocupa bastante espaço e tem muito HP
  const id = 'boss_' + Math.random().toString(36).slice(2);
  const bsize = 120 + Math.min(200, rIndex*6);
  const bossHP = 120 + rIndex * 60; // bem maior que inimigos normais
  enemies[id] = {
    id, typeName:'boss', x:WIDTH/2, y: -bsize, width:bsize, height:bsize,
    life: bossHP, maxLife: bossHP, color:'black', boss:true, ang:0, _lastShot:0
  };
  // spawn alguns minions para tornar boss mais perigoso
  for (let i=0;i<3;i++){
    spawnEnemyOfType('bossMinion');
  }
  addFloating(WIDTH/2, 80, 'CHEGOU O CHEFE (Sala ' + rIndex + ')', 'red', 2000);
}

/* ------------------ Room start / obstacles / pickups ------------------ */
function spawnRoomStart(){
  // clear existing entities & bullets, but keep upgrades/mutations
  enemies = {};
  bullets = {};
  pickups = {};
  floatingText = [];
  obstacles = [];

  // spawn initial enemies for the room: quantidade base + escala por room
  const base = 2 + Math.floor(roomIndex * 0.8);
  const toSpawn = base + Math.floor(Math.min(12, roomIndex / 2));
  for (let i=0;i<toSpawn;i++){
    const t = enemyPool[Math.floor(Math.random()*enemyPool.length)];
    spawnEnemyOfType(t);
  }
  killsThisRoom = 0;

  // gerar 0-4 obstáculos aleatórios (evitar central)
  const obsCount = Math.floor(rand(0,5));
  for (let i=0;i<obsCount;i++){
    // tenta posicionar sem sobrepor o player (simples)
    let w = Math.round(rand(40,120)), h = Math.round(rand(20,90));
    let x = rand(w/2 + 30, WIDTH - w/2 - 30);
    let y = rand(h/2 + 30, HEIGHT - h/2 - 30);
    // evitar spawn perto do player inicial (centro)
    if (Math.hypot(x - WIDTH/2, y - HEIGHT/2) < 140) {
      x += (x < WIDTH/2) ? -120 : 120;
      y += (y < HEIGHT/2) ? -80 : 80;
      x = clamp(x, w/2 + 10, WIDTH - w/2 - 10);
      y = clamp(y, h/2 + 10, HEIGHT - h/2 - 10);
    }
    obstacles.push({ x, y, w, h });
  }

  // spawn pickups por sala com chance baixíssima (4-6%)
  const coinChance = 0.045; // ~4.5%
  const rechargeChance = 0.05; // ~5%
  if (Math.random() < coinChance) spawnPickup('score', rand(60, WIDTH-60), rand(60, HEIGHT-60));
  if (Math.random() < rechargeChance) spawnPickup('recharge', rand(60, WIDTH-60), rand(60, HEIGHT-60));
}

/* ------------------ Spawn & Update Loop (ajustado) ------------------ */
function spawnTick(dt){
  spawnAccumulator += dt;
  // taxa de spawn depende do roomIndex / level
  const baseInterval = Math.max(0.4, 2.2 - roomIndex*0.12);
  while (spawnAccumulator > baseInterval){
    spawnAccumulator -= baseInterval;
    // escolha inimigo do pool cumulativo
    const t = enemyPool[Math.floor(Math.random()*enemyPool.length)];
    spawnEnemyOfType(t);
  }
  // reduzir pickups aleatórios contínuos (mantém mas raros)
  if (Math.random() < 0.001 + roomIndex*0.0004) spawnPickup('score');
  if (Math.random() < 0.0008 + roomIndex*0.0003) spawnPickup('recharge');
}

/* ------------------ Enemy behavior + contato dano ------------------ */
function updateEnemies(dt){
  for (const id in enemies){
    const e = enemies[id];
    // boss behavior
    if (e.boss){
      if (e.y < 140) e.y += 40 * dt;
      else {
        e.ang += dt * 0.4;
        e.x = WIDTH/2 + Math.cos(e.ang) * Math.max(120, 80 + roomIndex*2);
        e.y = 160 + Math.sin(e.ang) * 28;
        // boss dispara radial com cooldown reduzido com progresso
        if (!e._lastShot || now()-e._lastShot > 1200 - Math.min(800, roomIndex*40)){
          e._lastShot = now();
          for (let a=0;a<360;a+=30) spawnEnemyBullet(e.x, e.y, a);
        }
      }
    } else {
      // simples IA: mover em direção ao player, respeitar obstáculos
      const angle = Math.atan2(player.y - e.y, player.x - e.x);
      const spec = e.spec || ENEMY_TYPES[e.typeName] || ENEMY_TYPES.basic;
      let speed = (spec.baseSpeed || 40);
      speed *= (1 + roomIndex*0.03);
      // tentativa de step (simples) com checagem de colisão com obstáculos
      let nx = e.x + Math.cos(angle) * speed * dt;
      let ny = e.y + Math.sin(angle) * speed * dt;
      // checar colisão com obstáculos
      let coll = false;
      for (const o of obstacles){
        if (rectColRaw(nx, ny, e.width, e.height, o.x, o.y, o.w, o.h)){ coll = true; break; }
      }
      if (!coll){ e.x = nx; e.y = ny; } // se colidir, não se move naquele frame

      // ranged telegraph then shoot
      if (spec.ranged){
        e._tele = (e._tele||0) - dt;
        if (e._tele <= 0){
          e._tele = 2 + Math.random()*2;
          const ang = Math.atan2(player.y - e.y, player.x - e.x) * 180/Math.PI;
          spawnEnemyBullet(e.x, e.y, ang);
        }
      }
    }

    // contato dano: se colidir com player e cooldown expirado
    if (rectCol(e, player)){
      const dmg = (e.spec && e.spec.contactDamage) ? e.spec.contactDamage : 1;
      if (!e._hitTimer || now() - e._hitTimer > 450){ // dano a cada ~450ms por inimigo
        e._hitTimer = now();
        player.hp -= dmg;
        stats.damageTaken += dmg;
        killStreak = 0; slowTimer = 0; shake = Math.max(shake, 6);
        addFloating(player.x, player.y-18, '-' + dmg + ' HP', 'red', 900);
      }
    }
  }
}

/* ------------------ Bullets update (colisão com obstáculos) ------------------ */
function updateBullets(dt){
  for (const id in bullets){
    const b = bullets[id];
    b.timer += dt;
    b.x += b.xs * dt;
    b.y += b.ys * dt;

    // trail mutation visual
    if (Mutations['trail']) { if (Math.random() < 0.02) addFloating(b.x, b.y, '.', 'orange', 300); }

    // boundary check
    if (b.x < -50 || b.x > WIDTH+50 || b.y < -50 || b.y > HEIGHT+50){ delete bullets[id]; continue; }

    // check collision with obstacles: balas são destruídas ao bater
    let hitObstacle = false;
    for (const o of obstacles){
      if (rectColRaw(b.x, b.y, b.width, b.height, o.x, o.y, o.w, o.h)){ hitObstacle = true; break; }
    }
    if (hitObstacle){ delete bullets[id]; continue; }

    // player bullets hit enemies
    if (b.owner === 'player'){
      for (const eid in enemies){
        const en = enemies[eid];
        if (rectCol(b, en)){
          // apply damage (escalado)
          const applied = Math.round(b.damage) || 1;
          en.life -= applied;
          en.width = Math.max(6, en.width - applied * 0.2);
          en.height = Math.max(6, en.height - applied * 0.2);
          addFloating(en.x, en.y-10, '-' + Math.round(applied), 'yellow', 700);

          // burst on hit
          if (Mutations['burst_on_hit']) {
            const lvl = Mutations['burst_on_hit'].level;
            for (let a=0;a<360;a+=120){
              spawnBullet(a + rand(-10,10), {x:en.x, y:en.y}, {speed:240, damage:2 + lvl});
            }
          }

          // piercing
          if (Mutations['pierce']){
            b.pierced = (b.pierced||0) + 1;
            const maxPierce = Mutations['pierce'].level;
            if (b.pierced <= maxPierce){ /* passa */ } else { delete bullets[id]; }
          } else {
            delete bullets[id];
          }

          // death
          if (en.life <= 0 || en.width <= 8 || en.height <= 8){
            if (Mutations['explode_on_death']) {
              const lvl = Mutations['explode_on_death'].level;
              for (let a=0;a<360;a+=45) spawnBullet(a + rand(-8,8), {x:en.x, y:en.y}, {speed:320, damage:2 + lvl});
            }
            if (en.typeName === 'splitter'){ spawnEnemyOfType('fast'); spawnEnemyOfType('fast'); }
            if (Mutations['vampiric']) {
              const gain = Mutations['vampiric'].level;
              player.hp = Math.min(player.maxHP || (10 + Upgrades.maxHP*2), player.hp + gain);
            }
            // reward drop small chance on kill
            if (Math.random() < 0.05) spawnRewardDrop(en.x, en.y);

            delete enemies[eid];
            stats.kills++; killsThisRoom++; score += 150;
            killStreak++;
            if (killStreak >= 3) slowTimer = 800;

            // room clear check
            if (killsThisRoom >= enemiesToKillThisRoom){
              // limpa contador e avança para próxima sala
              killsThisRoom = 0;
              advanceRoom();
            }
          }
          break;
        }
      }
    } else {
      // enemy bullet hits player
      if (rectCol(b, player)){
        player.hp -= 1;
        stats.damageTaken++;
        killStreak = 0; slowTimer = 0; shake = 6;
        addFloating(player.x, player.y-18, '-1 HP', 'red', 900);
        delete bullets[id];
      }
    }
  }
}

/* enemy bullets */
function spawnEnemyBullet(x,y,angleDeg){
  const id = Math.random().toString(36).slice(2);
  const speed = 300 + roomIndex*6;
  bullets[id] = { id, x, y, width:6, height:6, xs:Math.cos(angleDeg*Math.PI/180)*speed, ys:Math.sin(angleDeg*Math.PI/180)*speed, timer:0, damage:2, owner:'enemy' };
}

/* pickups: 'score' and 'recharge' unchanged behavior; 'reward' usado para drops de boss/level */
function pickupCheck(){
  for (const id in pickups){
    const p = pickups[id];
    if (rectCol(p, player)){
      if (p.type === 'score'){ score += 1000; safePlay(S.coin); addFloating(player.x, player.y-20, '+1000', 'gold', 900); }
      else if (p.type === 'recharge'){ player.atkCounter += 250; safePlay(S.powerup); addFloating(player.x, player.y-20, 'RECHARGE', 'aqua', 900); }
      else if (p.type === 'reward'){
        if (Math.random() < 0.7) grantRandomMutation(); else grantRandomUpgrade();
      }
      delete pickups[id];
    }
  }
}

/* reward functions */
function spawnRewardDrop(x,y){
  spawnPickup('reward', x,y);
}

/* ------------------ Screen draw (inclui obstáculos + HUD special bar) ------------------ */
function drawAll(dt){
  // shake
  ctx.save();
  if (shake > 0) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);

  // background
  ctx.fillStyle = '#222'; ctx.fillRect(0,0,WIDTH,HEIGHT);

  // draw obstacles
  for (const o of obstacles){
    ctx.fillStyle = 'rgba(80,80,80,0.9)';
    ctx.fillRect(o.x - o.w/2, o.y - o.h/2, o.w, o.h);
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.strokeRect(o.x - o.w/2, o.y - o.h/2, o.w, o.h);
  }

  // pickups
  for (const id in pickups){
    const p = pickups[id];
    ctx.fillStyle = (p.type==='score')?'gold':(p.type==='recharge')?'aqua':'deepskyblue';
    ctx.fillRect(p.x - p.width/2, p.y - p.height/2, p.width, p.height);
  }

  // enemies
  for (const id in enemies){
    const e = enemies[id];
    if (e.spec && e.spec.ranged && e._tele && e._tele < 1.6 && e._tele > 0.5){
      ctx.fillStyle = 'rgba(255,200,0,0.12)';
      ctx.beginPath(); ctx.arc(e.x, e.y, Math.max(20, e.width), 0, Math.PI*2); ctx.fill();
    }
    ctx.fillStyle = e.color || 'maroon';
    ctx.fillRect(e.x - e.width/2, e.y - e.height/2, e.width, e.height);
    // boss health bar small
    if (e.boss){
      ctx.fillStyle='white'; ctx.font='14px Verdana'; ctx.fillText('CHEFE', e.x - 28, e.y - e.height/2 - 10);
      // life bar above boss
      const w = Math.min(160, e.width);
      const pct = Math.max(0, (e.life||0) / (e.maxLife||1));
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(e.x - w/2, e.y - e.height/2 - 18, w, 8);
      ctx.fillStyle = 'red';
      ctx.fillRect(e.x - w/2, e.y - e.height/2 - 18, w * pct, 8);
    }
  }

  // bullets
  for (const id in bullets){
    const b = bullets[id];
    ctx.fillStyle = '#000'; ctx.fillRect(b.x - b.width/2, b.y - b.height/2, b.width, b.height);
  }

  // player
  ctx.fillStyle = player.color; ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);

  // floating text
  const nowt = now();
  for (let i=floatingText.length-1;i>=0;i--){
    const f = floatingText[i];
    const age = nowt - f.created;
    if (age > f.ttl){ floatingText.splice(i,1); continue; }
    ctx.globalAlpha = clamp(1 - age/f.ttl, 0,1);
    ctx.fillStyle = f.color; ctx.font='14px Verdana'; ctx.fillText(f.txt, f.x, f.y - (age/30));
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

/* draw HUD and compact info (inclui special bar) */
function drawHUD(){
  // calcular special required atual
  const required = Math.max(50, 500 * (player.specialMod || 1));
  const current = clamp(player.atkCounter, 0, required);
  const pct = current / required;
  const specialBarWidth = Math.round(160 * pct);

  HUD.innerHTML = `
    SALA: ${roomIndex} &nbsp; LVL: ${level} &nbsp; SCORE: ${score}<br>
    HP: ${player.hp} &nbsp;&nbsp; KILLS-SALA: ${killsThisRoom}/${enemiesToKillThisRoom} &nbsp;&nbsp; KILLS-TOTAL: ${stats.kills}<br>
    Abilities: ${Object.keys(Mutations).length} &nbsp;&nbsp; Upgrades: ${Object.values(Upgrades).reduce((a,b)=>a+(b||0),0)}
    <div class="small" style="margin-top:6px">Special:
      <span class="special-bar"><span class="special-fill" style="width:${specialBarWidth}px;display:block;height:100%"></span></span>
      <span class="small" style="margin-left:8px"> ${Math.round(current)}/${Math.round(required)}</span>
    </div>
    <div class="small">Press TAB to show details</div>
  `;
  if (detailPanel.style.display !== 'none'){
    let upHTML = '<b>Upgrades</b><br>';
    UPGRADE_POOL.forEach(u=> upHTML += `${u.name}: Lvl ${Upgrades[u.key]||0}<br>`);
    detailUpgrades.innerHTML = upHTML;
    let muHTML = '<b>Mutations</b><br>';
    for (const k in Mutations){ const m = Mutations[k]; muHTML += `${m.name} (Lvl ${m.level}) — ${m.desc}<br>`; }
    if (!Object.keys(Mutations).length) muHTML += 'Nenhuma<br>';
    detailMutations.innerHTML = muHTML;
  }
}

/* ------------------ Game loop ------------------ */
function step(ts){
  if (!lastTs) lastTs = ts;
  let dtMs = ts - lastTs; lastTs = ts;
  if (dtMs > 120) dtMs = 120;
  // slow motion
  if (slowTimer > 0){ slowTimer -= dtMs; dtMs *= 0.45; } else { slowTimer = 0; }
  const dt = dtMs * 0.001;

  if (state === 'running'){
    spawnTick(dt);
    updateEnemies(dt);
    updateBullets(dt);
    pickupCheck();

    // movimento do player com colisão simples contra obstáculos
    const baseSpeed = 260 + Upgrades.moveSpeed*12;
    const speed = (player.hp <= 3 && Mutations['lowhp_speed']) ? baseSpeed*1.4 : baseSpeed;
    let nx = player.x, ny = player.y;
    if (player.pressing.right) nx += speed * dt;
    if (player.pressing.left) nx -= speed * dt;
    if (player.pressing.down) ny += speed * dt;
    if (player.pressing.up) ny -= speed * dt;
    // checar colisão com obstáculos
    let coll = false;
    for (const o of obstacles){
      if (rectColRaw(nx, ny, player.width, player.height, o.x, o.y, o.w, o.h)){ coll = true; break; }
    }
    if (!coll){ player.x = clamp(nx, player.width/2, WIDTH - player.width/2); player.y = clamp(ny, player.height/2, HEIGHT - player.height/2); }
    player.atkCounter += player.atkSpeed * dt * 60 * (1 + (Upgrades.specialCharge*0.05));
    if (player.atkCounter > 10000) player.atkCounter = 10000;

    applyAllMutations();

    // decrease shake
    if (shake > 0) shake = Math.max(0, shake - 0.3 * (dtMs/16));

    // update stats time
    stats.timeSurvived = now() - startTime;

    if (player.hp <= 0){ finishRun(); }
  }

  ctx.clearRect(0,0,WIDTH,HEIGHT);
  drawAll(dt);
  drawHUD();

  requestAnimationFrame(step);
}

/* ------------------ Player input & shooting (mantive comportamentos) ------------------ */
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  if (player) player.AimAngle = Math.atan2(my - player.y, mx - player.x) * 180 / Math.PI;
});
canvas.addEventListener('click', ()=>{
  if (state !== 'running') return;
  if (player.atkCounter > 50){
    safePlay(S.shoot);
    player.atkCounter -= 25;
    stats.shots++;
    if (Mutations['triple_shot']) {
      spawnBullet(player.AimAngle - 12, player); spawnBullet(player.AimAngle, player); spawnBullet(player.AimAngle + 12, player);
    } else if (Mutations['double_shot']){
      spawnBullet(player.AimAngle - 6, player); spawnBullet(player.AimAngle + 6, player);
    } else {
      spawnBullet(player.AimAngle, player);
    }
  }
});
canvas.addEventListener('contextmenu', e=>{
  e.preventDefault();
  if (state !== 'running') return;
  const required = Math.max(50, 500 * (player.specialMod || 1));
  if (player.atkCounter >= required){
    safePlay(S.supershoot);
    for (let a=0;a<360;a+=9) spawnBullet(a, player);
    player.atkCounter = 0;
    shake = 10;
    addFloating(player.x, player.y-20, 'SPECIAL!', 'yellow', 1200);
    return;
  }
  if (player.atkCounter >= 50){
    safePlay(S.bigshoot);
    player.atkCounter -= 50;
    for (let off=-15; off<=15; off+=10) spawnBullet(player.AimAngle + off, player);
  }
});

document.addEventListener('keydown', e=>{
  if (!player) return;
  if (e.key === 'w' || e.key === 'W') player.pressing.up = true;
  if (e.key === 's' || e.key === 'S') player.pressing.down = true;
  if (e.key === 'a' || e.key === 'A') player.pressing.left = true;
  if (e.key === 'd' || e.key === 'D') player.pressing.right = true;
  if (e.key === 'Tab'){ e.preventDefault(); toggleDetails(); }
});
document.addEventListener('keyup', e=>{
  if (!player) return;
  if (e.key === 'w' || e.key === 'W') player.pressing.up = false;
  if (e.key === 's' || e.key === 'S') player.pressing.down = false;
  if (e.key === 'a' || e.key === 'A') player.pressing.left = false;
  if (e.key === 'd' || e.key === 'D') player.pressing.right = false;
});

/* toggle detail panel */
function toggleDetails(){
  detailPanel.style.display = (detailPanel.style.display === 'none') ? 'block' : 'none';
}

/* ------------------ Run control ------------------ */
let startTime = 0;
btnStart.addEventListener('click', ()=>{ startRun(); });
btnRestart.addEventListener('click', ()=>{ startRun(); gameover.style.display='none'; });

function startRun(){
  state = 'running';
  menu.style.display = 'none';
  gameover.style.display = 'none';
  enemies = {}; bullets = {}; pickups = {}; floatingText = []; obstacles = []; Mutations = Mutations || {};
  for (const k in Upgrades) Upgrades[k]=0;
  for (const k in Mutations) delete Mutations[k];
  initRoomSystem();
  applyUpgradeEffects();
  createPlayer();
  score = 0; stats = { shots:0, hits:0, kills:0, damageTaken:0, timeSurvived:0 };
  spawnAccumulator = 0; killsThisRoom = 0;
  // start com alguns inimigos (feito em spawnRoomStart)
  startTime = now();
  lastTs = 0;
  requestAnimationFrame(step);
}

/* finish run */
function finishRun(){
  state = 'gameover';
  gameover.style.display = 'flex';
  goStats.innerHTML = `Score: ${score}<br>Kills: ${stats.kills}<br>Time: ${Math.round(stats.timeSurvived/1000)}s<br>Salas: ${roomIndex}<br>
    <div class="small">Upgrades: ${Object.values(Upgrades).reduce((a,b)=>a+(b||0),0)} • Mutations: ${Object.keys(Mutations).length}</div>`;
}

/* ------------------ Inicial UI ------------------ */
menu.style.display='flex';
gameover.style.display='none';
detailPanel.style.display='none';
createPlayer();
requestAnimationFrame(step);

</script>
</body>
</html>
